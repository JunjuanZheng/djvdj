---
output: github_document
params:
  vdj_dir: "~/Projects/Smith_AVIDseq/2020-07-17/BCR/outs"
  clust_res: 0.2
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse  = TRUE,
  comment   = "#>",
  fig.path  = "man/figures/README-",
  out.width = "100%",
  warning   = FALSE,
  message   = FALSE
)
```

# djvdj <img src="man/figures/djvdj-logo.png" align="right" height="145">

<!-- badges: start -->
[![R build status](https://github.com/rnabioco/djvdj/workflows/R-CMD-check/badge.svg)](https://github.com/rnabioco/djvdj/actions)
<!-- badges: end -->

The goal of djvdj is to provide tools to analyze AVID-seq signals alongside single-cell VDJ sequencing data.

<br>

## Installation

You can install the development version of djvdj from [GitHub](https://github.com/rnabioco/djvdj) with:

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("rnabioco/djvdj")
```

```{r "functions", echo = FALSE}
# Create color palette
create_gradient <- function(cols_in, n = NULL) {
  
  if (is.null(n)) {
    n <- length(cols_in)
  }
  
  colorRampPalette(cols_in)(n)
}

create_col_fun <- function(cols_in) {
  
  function(n = NULL) {
    create_gradient(cols_in, n)
  }
}
```

```{r "Setup", include = FALSE}
# Packages
library(tidyverse)
library(cowplot)
library(colorblindr)
library(Seurat)
library(here)
library(djvdj)

# Themes
text_theme <- theme(
  legend.title = element_text(size = 10),
  legend.text  = element_text(size = 10),
  axis.title   = element_text(size = 12),
  axis.text    = element_text(size = 10)
)

base_theme <- theme_cowplot() +
  theme(
    plot.title       = element_text(face = "plain", size = 20),
    strip.background = element_blank(),
    strip.text       = element_text(face = "plain"),
    axis.line        = element_line(color = "grey85"),
    axis.ticks       = element_line(color = "grey85")
  ) +
  text_theme

umap_theme <- base_theme +
  theme(
    axis.title = element_blank(),
    axis.line  = element_blank(),
    axis.ticks = element_blank(),
    axis.text  = element_blank()
  )

# Legend guides
create_guide <- function(size = 3.5, shape = 16, nrow = NULL,
                         ncol = NULL, ...) {
  guide_legend(
    nrow = nrow,
    ncol = ncol,
    override.aes = list(
      size   = size,
      shape  = shape,
      ...
    )
  )
}

col_guide <- create_guide(shape = 16, stroke = NULL, color = NULL)

# Okabe Ito color palettes
ito_cols <- c(
  palette_OkabeIto[1:4], "#d7301f", 
  palette_OkabeIto[5:6], "#6A51A3", 
  palette_OkabeIto[7:8], "#875C04"
)

# Set default palette
get_cols <- create_col_fun(ito_cols)
```

<br>

## Vignette

Splenocytes from MD4 transgenic mice which have monoclonal B cells that all bind hen egg lysozyme (HEL) antigen were mixed with splenocytes from C57BL/6 mice at a 1:20 ratio. The cells were stained with the HEL AVID-tag and sequencing libraries were prepared to capture gene expression, B cell receptor sequences, and AVID-tag signals using the 10x Genomics 5â€™ immune profiling kit.

```{r "rna_umap", fig.width = 12.5, fig.height = 5, echo = FALSE}
load("data/so_tcr.rda")

key_gg <- so_tcr %>%
  plot_features(
    feature     = "type_mouse",
    pt_size     = 0.02,
    plot_colors = get_cols()
  ) +
  ggtitle("Cell type") +
  guides(color = create_guide()) +
  umap_theme +
  theme(
    panel.border = element_blank(),
    legend.title = element_blank()
  )

clust_gg <- so_tcr %>%
  plot_features(
    feature     = "seurat_clusters",
    pt_size     = 0.02,
    plot_colors = get_cols(22)
  ) +
  ggtitle("Cluster") +
  guides(color = create_guide()) +
  umap_theme +
  theme(
    panel.border = element_blank(),
    legend.title = element_blank()
  )

plot_grid(
  key_gg, clust_gg,
  rel_widths = c(1, 0.9),
  align      = "h",
  axis       = "tb"
)
```

<br>

### Import VDJ data

`import_vdj` takes the output files from `cellranger vdj` and adds clonotype information to the meta.data for an existing Seurat object. For cells that do not have any VDJ sequencing data, NAs will be included in the meta.data. The `filter_contigs` argument will only include chains that have at least one contig that is full length and productive.

```{r "import_vdj", eval = F}
so_vdj <- import_vdj(
  sobj_in        = so_vdj,          # Seurat object                         
  vdj_dir        = params$vdj_dir,  # Directory containing cellranger output files
  prefix         = "",              # Prefix to add to new meta.data columns
  cell_prefix    = "",              # Prefix to add to cell barcodes
  filter_contigs = TRUE             # Only include chains with at least one productive contig
)
```

<br>

### Filtering

`filter_vdj` allows you to filter a Seurat object using the added clonotype information or any other columns present in the meta.data. For cells with multiple chains, the information for each chain is stored as a single row, separated by a ";". When filtering, columns with VDJ data will be expanded based on the delimiter ";". The columns that are expanded for filtering can be specified with the `split_cols` argument. By default filtering is only performed on cells that include VDJ data.

Filter to only include cells with paired light and heavy chains.

```{r}
so_filt <- filter_vdj(
  sobj_in = so_vdj,                                                # Seurat object
  filt    = "IGH" %in% chains && any(c("IGK", "IGL") %in% chains)  # Expression for filtering
)

so_filt@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

<br>

Instead of filtering, `filter_vdj` can also add new cell labels to the object meta.data using the `new_col` argument. Here a new column is added indicating whether each cell has a paired heavy and light chain. This is useful for plotting.

```{r}
so_vdj <- filter_vdj(
  sobj_in = so_vdj,                                                 # Seurat object
  filt    = "IGH" %in% chains && any(c("IGK", "IGL") %in% chains),  # Condition to use for filtering
  new_col = "Paired",                                               # Name of new column
  true    = "paired",                                               # Value when condition is TRUE
  false   = "unpaired"                                              # Value when condition is FALSE
)

vdj_cols <- c(vdj_cols, "Paired")

so_vdj@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

```{r "pair_umap", fig.width = 12, fig.height = 5, echo = FALSE}
# Plot colors
pairs_cols <- so_vdj@meta.data %>%
  pull(Paired) %>%
  unique() %>%
  na.omit()

pairs_cols <- set_names(
  x  = get_cols()[seq_along(pairs_cols)],
  nm = pairs_cols
)

pairs_cols["NA"] <- "#f0f0f0"

# Paired UMAP
pairs_umap <- so_vdj %>%
  plot_features(
    x           = "UMAP_1",
    y           = "UMAP_2",
    feature     = "Paired",
    pt_size     = 0.02,
    plot_colors = pairs_cols
  ) +
  ggtitle("Paired chains") +
  guides(color = create_guide(nrow = 2)) +
  umap_theme +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Paired bar graphs
pairs_bars <- so_vdj %>%
  plot_cell_count(
    x           = "mouse",
    fill_col    = "Paired",
    plot_colors = pairs_cols,
    size        = 0.2,
    color       = "black"
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  base_theme +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank()
  )

pairs_bars <- plot_grid(
  pairs_bars, NULL,
  rel_widths = c(0.4, 1)
)

# Final figure
plot_grid(
  pairs_umap, pairs_bars,
  rel_widths = c(0.65, 1),
  nrow  = 1,
  align = "h",
  axis  = "tb"
)
```

<br>

More complicated statements referring to meta.data columns can be used for the `filt`, `true`, and `false` arguments. For more detailed analysis of the chains detected for each cell, a new cell label can be created for only the unique chains.

```{r}
so_vdj <- filter_vdj(
  sobj_in = so_vdj,                                # Seurat object
  new_col = "uniq_chains",                         # Name of new column
  true    = str_c(unique(chains), collapse = "_")  # Value when condition is TRUE
)

vdj_cols <- c(vdj_cols, "uniq_chains")

so_vdj@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id), n_chains > 2) %>%
  select(all_of(vdj_cols))
```

```{r "chains_umap", fig.width = 12, fig.height = 5, echo = FALSE}
# Plot colors
chains_cols <- so_vdj@meta.data %>%
  pull(uniq_chains) %>%
  unique() %>%
  na.omit()

chains_cols <- set_names(
  x  = get_cols()[seq_along(chains_cols)],
  nm = chains_cols
)

chains_cols["NA"] <- "#f0f0f0"

# Chains UMAP
chains_umap <- so_vdj %>%
  plot_features(
    feature     = "uniq_chains",
    pt_size     = 0.02,
    plot_colors = chains_cols
  ) +
  ggtitle("Unique chains") +
  guides(color = create_guide(nrow = 2)) +
  umap_theme +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Chains bar graphs
chains_bars <- so_vdj %>%
  plot_cell_count(
    x           = "mouse",
    fill_col    = "uniq_chains",
    plot_colors = chains_cols,
    size        = 0.2,
    color       = "black"
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  base_theme +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank()
  )

chains_bars <- plot_grid(
  chains_bars, NULL,
  rel_widths = c(0.4, 1)
)

# Final figure
plot_grid(
  chains_umap, chains_bars,
  rel_widths = c(0.65, 1),
  nrow       = 1,
  align      = "h",
  axis       = "tb"
)
```

<br>

### Repertoire stats

The functions `calc_diversity` and `calc_similarity` will calculate repertoire diversity and repertoire similarity on a per-cluster basis. These functions can be given any meta.data column containing cell labels to use for calculations.

Calculate repertoire diversity with `calc_diversity`.

```{r}
so_vdj <- calc_diversity(
  sobj_in       = so_vdj,          # Seurat object
  clonotype_col = "clonotype_id",  # meta.data column containing clonotype ids
  cluster_col   = "type_mouse",    # meta.data column containing cell labels
  method        = "shannon"        # Method to use
)
```

Plotting functions are also provided to summarize diversity metrics

```{r "div_umap", fig.width = 12, fig.height = 5, echo = FALSE}

plot_diversity(
  sobj_in       = so_vdj,          # Seurat object
  clonotype_col = "clonotype_id",  # meta.data column containing clonotype ids
  cluster_col   = "mouse",         # meta.data column containing cell labels
  method        = "shannon",       # Method to use
  plot_colors   = ito_cols 
) +
  theme_cowplot() +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank()
  )



# div_gg <- so_vdj %>% 
#   plot_features(
#     feature    = "diversity",
#     pt_size    = 0.02,
#     pt_outline = 0.2,
#     plot_colors  = c("grey90", get_cols()[1]),
#     na_value   = "grey60"
#   ) +
#   ggtitle("Repertoire Diversity") +
#   guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
#   umap_theme +
#   theme(legend.title = element_blank())
# 
# hel_gg <- so_vdj %>%
#   plot_features(
#     feature    = "adt_HEL",
#     pt_size    = 0.02,
#     pt_outline = 0.2,
#     plot_colors  = c("grey90", get_cols()[6])
#   ) +
#   ggtitle("HEL") +
#   guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
#   umap_theme +
#   theme(legend.title = element_blank())
# 
# plot_grid(
#   div_gg, hel_gg,
#   align  = "vh",
#   "axis" = "trbl"
# )
```

<br>

Calculate repertoire overlap with `calc_jaccard` for the cell groups present in the `cluster_col`. Using the `return_seurat` argument, `calc_jaccard` can also output a matrix for plotting.

```{r}
so_vdj <- calc_overlap(
  sobj_in       = so_vdj,             # Seurat object
  clonotype_col = "clonotype_id",     # meta.data column containing clonotype ids
  cluster_col   = "seurat_clusters",  # meta.data column containing cell labels
  prefix        = "x",                # Prefix to add to new meta.data columns 
  return_seurat = TRUE                # Return Seurat object with results added to meta.data
)
```

```{r "jaccard_umap", fig.width = 12.5, fig.height = 5, echo = FALSE}
# Jaccard UMAP
j_gg <- so_vdj %>%
  plot_features(
    feature    = "x8",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_colors  = c("grey90", get_cols()[2]),
    na_value   = "grey60"
  ) +
  ggtitle("Repertoire Overlap") +
  guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
  umap_theme +
  theme(legend.text = element_text(size = 8))

# Matrix for heatmap
j_heat <- plot_overlap(
  obj_in        = so_vdj,
  clonotype_col = "clonotype_id",
  cluster_col   = "seurat_clusters",
  plot_colors   = c("grey90", get_cols()[2]),
  size          = 1,
  color         = "white"
) +
  guides(fill = guide_colorbar(barwidth = unit(5, "pt"))) +
  base_theme +
  theme(
    legend.text = element_text(size = 8),
    axis.title  = element_blank(),
    axis.line   = element_blank(),
    axis.ticks  = element_blank()
  )

# Final figure
plot_grid(
  j_gg, j_heat,
  align = "h",
  axis  = "tb"
  )
```

```{r "enclone_test", eval = FALSE, echo = FALSE}
# To run enclone
#enclone \
#    BCR=BCR/outs \
#    REF=ref/refdata-cellranger-vdj-GRCm38-alts-ensembl-3.1.0/fasta/regions.fa \
#    POUT="enclone_out.csv" \
#    PCOLS=group_id,group_ncells,clonotype_id,clonotype_ncells,barcodes

# Import enclone results
en_df <- read_csv("~/Projects/Smith_AVIDseq/2020-07-17/enclone_out.csv") %>%
  mutate(barcodes = str_split(barcodes, ",")) %>%
  unnest(barcodes) %>%
  select(cell_id = barcodes, group_id, group_ncells) %>%
  filter(group_ncells > 1)

# Merge enclone groups with meta.data
en_df <- so_vdj@meta.data %>%
  as_tibble(rownames = "cell_id") %>%
  left_join(en_df, by = "cell_id") %>%
  mutate(
    group_id = as.character(group_id),
    group_id = replace_na(group_id, "NA")
  )

# Group colors
grp_cols <- en_df %>%
  pull(group_id) %>%
  unique()

grp_cols <- set_names(
  x  = c(ito_cols, darken(ito_cols, 0.2))[seq_along(grp_cols)],
  nm = grp_cols
)

grp_cols["NA"] <- "white"

# Overlay enclone groups on UMAP
en_df %>%
  mutate(group_id = fct_relevel(group_id, names(grp_cols))) %>%
  plot_features(
    x          = "vdjUMAP_1",
    y          = "vdjUMAP_2",
    feature    = "group_id",
    pt_outline = 0.3,
    plot_colors  = grp_cols
  ) +
  umap_theme +
  guides(color = guide_legend(override.aes = list(size = 3))
```





