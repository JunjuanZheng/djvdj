---
output: github_document
params:
  vdj_dir: "~/Projects/Smith_AVIDseq/2020-07-17/BCR/outs"
  clust_res: 0.2
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse  = TRUE,
  comment   = "#>",
  fig.path  = "man/figures/README-",
  out.width = "100%",
  warning   = FALSE,
  message   = FALSE
)
```

# djvdj <img src="man/figures/djvdj-logo.png" align="right" height="145">

<!-- badges: start -->
[![R build status](https://github.com/rnabioco/djvdj/workflows/R-CMD-check/badge.svg)](https://github.com/rnabioco/djvdj/actions)
<!-- badges: end -->

The goal of djvdj is to provide tools to analyze AVID-seq signals alongside single-cell VDJ sequencing data.

<br>

## Installation

You can install the development version of djvdj from [GitHub](https://github.com/rnabioco/djvdj) with:

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("rnabioco/djvdj")
```

```{r "functions", echo = FALSE}
# Create color palette
create_gradient <- function(cols_in, n = NULL) {
  
  if (is.null(n)) {
    n <- length(cols_in)
  }
  
  colorRampPalette(cols_in)(n)
}

create_col_fun <- function(cols_in) {
  
  function(n = NULL) {
    create_gradient(cols_in, n)
  }
}

# Overlay feature data on UMAP or tSNE
# Cannot change number of columns when using FeaturePlot with split.by
plot_features <- function(sobj_in, x = "UMAP_1", y = "UMAP_2", feature, data_slot = "data", 
                          split_id = NULL, pt_size = 0.25, pt_outline = NULL, plot_cols = NULL,
                          feat_levels = NULL, split_levels = NULL, min_pct = NULL, max_pct = NULL, 
                          calc_cor = F, lm_line = F, lab_size = 3.7, lab_pos = c(0.8, 0.9),
                          na_value = "#f0f0f0", ...) {
  
  # Format imput data
  counts <- sobj_in
  
  if ("Seurat" %in% class(sobj_in)) {
    vars <- c(x, y, feature)
    
    if (!is.null(split_id)) {
      vars <- c(vars, split_id)
    }

    counts <- sobj_in %>%
      FetchData(vars = unique(vars), slot = data_slot) %>%
      as_tibble(rownames = "cell_ids")
  }
  
  # Rename features
  if (!is.null(names(feature))) {
    counts <- counts %>%
      rename(!!!syms(feature))
    
    feature <- names(feature)
  }
  
  if (!is.null(names(x))) {
    counts <- counts %>%
      rename(!!!syms(x))
    
    x <- names(x)
  }
  
  if (!is.null(names(y))) {
    counts <- counts %>%
      rename(!!!syms(y))
    
    y <- names(y)
  }
  
  # Set min and max values for feature
  if (!is.null(min_pct) || !is.null(max_pct)) {
    counts <- counts %>%
      mutate(
        pct_rank = percent_rank(!!sym(feature)),
        max_val  = ifelse(pct_rank > max_pct, !!sym(feature), NA),
        max_val  = min(max_val, na.rm = T),
        min_val  = ifelse(pct_rank < min_pct, !!sym(feature), NA),
        min_val  = max(min_val, na.rm = T),
        !!sym(feature) := if_else(!!sym(feature) > max_val, max_val, !!sym(feature)),
        !!sym(feature) := if_else(!!sym(feature) < min_val, min_val, !!sym(feature))
      )
  }

  # Set feature order
  if (!is.null(feat_levels)) {
    counts <- counts %>%
      mutate(!!sym(feature) := fct_relevel(!!sym(feature), feat_levels))
  }
  
  # Set facet order
  if (!is.null(split_id) && length(split_id) == 1) {
    counts <- counts %>%
      mutate(split_id = !!sym(split_id))
    
    if (!is.null(split_levels)) {
      counts <- counts %>%
        mutate(split_id = fct_relevel(split_id, split_levels))
    }
  }
  
  # Calculate correlation
  if (calc_cor) {
    if (!is.null(split_id)) {
      counts <- counts %>%
        group_by(split_id)
    }
    
    counts <- counts %>%
      mutate(
        r       = tidy(cor.test(!!sym(x), !!sym(y)))$estimate,
        r       = round(r, digits = 2),
        pval    = tidy(cor.test(!!sym(x), !!sym(y)))$p.value,
        cor_lab = str_c("r = ", r, ", p = ", format(pval, digits = 2))
        
        # cor_lab = cor(!!sym(x), !!sym(y)),
        # cor_lab = round(cor_lab, digits = 2),
        # cor_lab = str_c("r = ", cor_lab),
      )
    
    if (lab_pos != "strip") {
      counts <- counts %>%
        mutate(
          min_x = min(!!sym(x)),
          max_x = max(!!sym(x)),
          min_y = min(!!sym(y)),
          max_y = max(!!sym(y)),
          lab_x = (max_x - min_x) * lab_pos[1] + min_x,
          lab_y = (max_y - min_y) * lab_pos[2] + min_y
        )
    }
  }
  
  # Create scatter plot
  # To add outline for each cluster create separate layers
  res <- counts %>%
    arrange(!!sym(feature))
  
  if (!is.null(pt_outline)) {
    
    if (!is.numeric(counts[[feature]])) {
      res <- res %>%
        ggplot(aes(!!sym(x), !!sym(y), color = !!sym(feature), fill = !!sym(feature)))
      
      feats <- counts[[feature]] %>%
        unique()
      
      if (!is.null(feat_levels)) {
        feats <- feat_levels[feat_levels %in% feats]
      }
      
      for (feat in feats) {
        if (is.na(feat)) {
          feat <- "NA"
        }
        
        f_counts <- counts %>%
          mutate(!!sym(feature) := replace_na(!!sym(feature), "NA")) %>%
          filter(!!sym(feature) == feat)
        
        res <- res +
          geom_point(
            data        = f_counts,
            mapping     = aes(fill = !!sym(feature)),
            size        = pt_outline,
            color       = "black",
            show.legend = F
          ) +
          geom_point(data = f_counts, size = pt_size)
      }
      
    } else {
      res <- res %>%
        ggplot(aes(!!sym(x), !!sym(y), color = !!sym(feature))) +
        geom_point(aes(fill = !!sym(feature)), size = pt_outline, color = "black", show.legend = F) +
        geom_point(size = pt_size)
    }
    
  } else {
    res <- res %>%
      ggplot(aes(!!sym(x), !!sym(y), color = !!sym(feature))) +
      geom_point(size = pt_size)
  }

  # Add regression line
  if (lm_line) {
    res <- res +
      geom_smooth(
        method   = "lm",
        se       = F,
        color    = "black",
        size     = 0.5,
        linetype = 2
      )
  }
  
  # Add correlation coefficient label
  if (calc_cor && lab_pos != "strip") {
    res <- res +
      geom_text(
        mapping       = aes(lab_x, lab_y, label = cor_lab),
        color         = "black",
        size          = lab_size,
        check_overlap = T, 
        show.legend   = F
      )
  }
  
  # Set feature colors
  if (!is.null(plot_cols)) {
    if (is.numeric(counts[[feature]])) {
      res <- res +
        scale_color_gradientn(colors = plot_cols, na.value = na_value)
        # scale_color_gradient(low = plot_cols[1], high = plot_cols[2])

    } else {
      res <- res +
        scale_color_manual(values = plot_cols, na.value = na_value) +
        scale_fill_manual(values = plot_cols, na.value = na_value)
    }
  }
  
  # Split plot into facets
  cor_labeller <- function(labels) {
    labels %>%
      map(~ {
        cor_labs <- counts %>%
          ungroup() %>%
          select(!!sym(feature), cor_lab) %>%
          unique()
        
        cor_labs <- set_names(cor_labs$cor_lab, cor_labs[[feature]])
        
        str_c(.x, "\n", cor_labs[.x])
      })
  }
  
  if (!is.null(split_id)) {
    if (length(split_id) == 1) {
      
      if (calc_cor && lab_pos == "strip") {
        my_labs <- cor_labeller
        
      } else {
        my_labs <- "label_value"
      }
      
      res <- res +
        facet_wrap(~ split_id, labeller = my_labs, ...)
      
    } else if (length(split_id) == 2) {
      eq <- str_c(split_id[1], " ~ ", split_id[2])
      
      res <- res +
        facet_grid(as.formula(eq), ...)
    }
  }
  
  res
}

# Plot fraction of cells containing given labels
plot_cell_count <- function(sobj_in, group_id, split_id = NULL, group_order = NULL, fill_id, 
                            plot_cols = NULL, x_lab = "Cell type", y_lab = "Fraction of cells",
                            bar_pos = "fill", order_count = T, bar_line = 0, na_value = "#f0f0f0",
                            ...) {
  
  res <- sobj_in
  
  if ("Seurat" %in% class(sobj_in)) {
    res <- sobj_in@meta.data %>%
      rownames_to_column("cell_id")
  }
  
  res <- res %>%
    mutate(
      group_id := !!sym(group_id),
      fill_id  := !!sym(fill_id)
    )
  
  if (!is.null(group_order)) {
    res <- res %>%
      mutate(group_id = fct_relevel(group_id, group_order))
  }
  
  if (!is.null(split_id)) {
    res <- res %>%
      mutate(split_id := !!sym(split_id))
  }
  
  if (order_count) {
    res <- res %>%
      mutate(fill_id = fct_reorder(fill_id, cell_id, n_distinct))
  }

  res <- res %>%
    ggplot(aes(group_id, fill = fill_id)) +
    geom_bar(position = bar_pos, size = bar_line, color = "black") +
    labs(x = x_lab, y = y_lab)
  
  if (!is.null(plot_cols)) {
    res <- res +
      scale_fill_manual(values = plot_cols, na.value = na_value)
    
  } else {
    res <- res +
      scale_fill_manual(na.value = na_value)
  }
  
  if (!is.null(split_id)) {
    res <- res +
      facet_wrap(~ split_id, ...)
  }
  
  res
}
```

```{r "Setup", include = FALSE}
# Packages
library(tidyverse)
library(cowplot)
library(colorblindr)
library(Seurat)
library(here)
library(djvdj)

# Themes
text_theme <- theme(
  legend.title = element_text(size = 10),
  legend.text  = element_text(size = 10),
  axis.title   = element_text(size = 12),
  axis.text    = element_text(size = 10)
)

base_theme <- theme_cowplot() +
  theme(
    plot.title       = element_text(face = "plain", size = 20),
    strip.background = element_blank(),
    strip.text       = element_text(face = "plain"),
    axis.line        = element_line(color = "grey85"),
    axis.ticks       = element_line(color = "grey85")
  ) +
  text_theme

umap_theme <- base_theme +
  theme(
    axis.title = element_blank(),
    axis.line  = element_blank(),
    axis.ticks = element_blank(),
    axis.text  = element_blank()
  )

# Legend guides
create_guide <- function(size = 3.5, shape = 21, color = "black",
                         stroke = 0.25, nrow = NULL, ncol = NULL, ...) {
  guide_legend(
    nrow = nrow,
    ncol = ncol,
    override.aes = list(
      size   = size,
      shape  = shape,
      color  = color,
      stroke = stroke,
      ...
    )
  )
}

col_guide <- create_guide(shape = 16, stroke = NULL, color = NULL)

# Okabe Ito color palettes
ito_cols <- c(
  palette_OkabeIto[1:4], "#d7301f", 
  palette_OkabeIto[5:6], "#6A51A3", 
  palette_OkabeIto[7:8], "#875C04"
)

# Set default palette
get_cols <- create_col_fun(ito_cols)
```

<br>

## Vignette

Splenocytes from MD4 transgenic mice which have monoclonal B cells that all bind hen egg lysozyme (HEL) antigen were mixed with splenocytes from C57BL/6 mice at a 1:20 ratio. The cells were stained with the HEL AVID-tag and sequencing libraries were prepared to capture gene expression, B cell receptor sequences, and AVID-tag signals using the 10x Genomics 5’ immune profiling kit.

```{r "rna_umap", fig.width = 12.5, fig.height = 5, echo = FALSE}
key_gg <- so %>%
  plot_features(
    feature    = "type_mouse",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = get_cols()
  ) +
  ggtitle("Cell type") +
  guides(color = create_guide()) +
  umap_theme +
  theme(
    panel.border = element_blank(),
    legend.title = element_blank()
  )

clust_gg <- so %>%
  plot_features(
    feature    = "seurat_clusters",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = get_cols(22)
  ) +
  ggtitle("Cluster") +
  guides(color = create_guide()) +
  umap_theme +
  theme(
    panel.border = element_blank(),
    legend.title = element_blank()
  )

plot_grid(
  key_gg, clust_gg,
  rel_widths = c(1, 0.9),
  align      = "h",
  axis       = "tb"
)
```

<br>

### Import VDJ data

`import_vdj` takes the output files from `cellranger vdj` and adds clonotype information to the meta.data for an existing Seurat object. For cells that do not have any VDJ sequencing data, NAs will be included in the meta.data. The `filter_contigs` argument will only include chains that have at least one contig that is full length and productive.

```{r "import_vdj"}
so_vdj <- import_vdj(
  sobj_in        = so,              # Seurat object                         
  vdj_dir        = params$vdj_dir,  # Directory containing cellranger output files
  prefix         = "",              # Prefix to add to new meta.data columns
  cell_prefix    = "",              # Prefix to add to cell barcodes
  filter_contigs = TRUE             # Only include chains with at least one productive contig
)

vdj_cols <- c(
  "chain",      "cdr3",
  "clone_freq", "clone_prop",
  "n_chains"
)

so_vdj@meta.data %>%
  as_tibble() %>%
  select(orig.ident, nCount_RNA, nFeature_RNA, all_of(vdj_cols))
```

<br>

### Filtering

`filter_vdj` allows you to filter a Seurat object using the added clonotype information or any other columns present in the meta.data. For cells with multiple chains, the information for each chain is stored as a single row, separated by a ";". When filtering, columns with VDJ data will be expanded based on the delimiter ";". The columns that are expanded for filtering can be specified with the `split_cols` argument. By default filtering is only performed on cells that include VDJ data.

Filter to only include cells with paired light and heavy chains.

```{r}
so_filt <- filter_vdj(
  sobj_in = so_vdj,                                              # Seurat object
  filt    = "IGH" %in% chain && any(c("IGK", "IGL") %in% chain)  # Expression for filtering
)

so_filt@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

<br>

Instead of filtering, `filter_vdj` can also add new cell labels to the object meta.data using the `new_col` argument. Here a new column is added indicating whether each cell has a paired heavy and light chain. This is useful for plotting.

```{r}
so_vdj <- filter_vdj(
  sobj_in = so_vdj,                                               # Seurat object
  filt    = "IGH" %in% chain && any(c("IGK", "IGL") %in% chain),  # Condition to use for filtering
  new_col = "Paired",                                             # Name of new column
  true    = "paired",                                             # Value when condition is TRUE
  false   = "unpaired"                                            # Value when condition is FALSE
)

vdj_cols <- c(vdj_cols, "Paired")

so_vdj@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

```{r "pair_umap", fig.width = 12, fig.height = 5, echo = FALSE}
# Plot colors
pairs_cols <- so_vdj@meta.data %>%
  pull(Paired) %>%
  unique() %>%
  na.omit()

pairs_cols <- set_names(
  x  = get_cols()[seq_along(pairs_cols)],
  nm = pairs_cols
)

pairs_cols["NA"] <- "#f0f0f0"

# Paired UMAP
pairs_umap <- so_vdj %>%
  plot_features(
    x          = "UMAP_1",
    y          = "UMAP_2",
    feature    = "Paired",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = pairs_cols
  ) +
  ggtitle("Paired chains") +
  guides(color = create_guide(nrow = 2)) +
  umap_theme +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Paired bar graphs
pairs_bars <- so_vdj %>%
  plot_cell_count(
    group_id  = "mouse",
    fill_id   = "Paired",
    plot_cols = pairs_cols,
    bar_line  = 0.2
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  base_theme +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank()
  )

pairs_bars <- plot_grid(
  pairs_bars, NULL,
  rel_widths = c(0.4, 1)
)

# Final figure
plot_grid(
  pairs_umap, pairs_bars,
  rel_widths = c(0.65, 1),
  nrow  = 1,
  align = "h",
  axis  = "tb"
)
```

<br>

More complicated statements referring to meta.data columns can be used for the `filt`, `true`, and `false` arguments. For more detailed analysis of the chains detected for each cell, a new cell label can be created for only the unique chains.

```{r}
so_vdj <- filter_vdj(
  sobj_in = so_vdj,                                # Seurat object
  filt    = length(unique(chain)) < 4,             # Condition to use for filtering
  new_col = "uniq_chains",                         # Name of new column
  true    = str_c(unique(chain), collapse = "_"),  # Value when condition is TRUE
  false   = "other"                                # Value when condition is FALSE
)

vdj_cols <- c(vdj_cols, "uniq_chains")

so_vdj@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id), n_chains > 2) %>%
  select(all_of(vdj_cols))
```

```{r "chains_umap", fig.width = 12, fig.height = 5, echo = FALSE}
# Plot colors
chains_cols <- so_vdj@meta.data %>%
  pull(uniq_chains) %>%
  unique() %>%
  na.omit()

chains_cols <- set_names(
  x  = get_cols()[seq_along(chains_cols)],
  nm = chains_cols
)

chains_cols["NA"] <- "#f0f0f0"

# Chains UMAP
chains_umap <- so_vdj %>%
  plot_features(
    feature    = "uniq_chains",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = chains_cols
  ) +
  ggtitle("Unique chains") +
  guides(color = create_guide(nrow = 2)) +
  umap_theme +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Chains bar graphs
chains_bars <- so_vdj %>%
  plot_cell_count(
    group_id  = "mouse",
    fill_id   = "uniq_chains",
    plot_cols = chains_cols,
    bar_line  = 0.2
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  base_theme +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank()
  )

chains_bars <- plot_grid(
  chains_bars, NULL,
  rel_widths = c(0.4, 1)
)

# Final figure
plot_grid(
  chains_umap, chains_bars,
  rel_widths = c(0.65, 1),
  nrow  = 1,
  align = "h",
  axis  = "tb"
)
```

<br>

MD4 B cells are expected to have IGK chains with the CDR3 amino acid sequence CQQSNSWPYTF. Using `filter_vdj` we can visualize which cells have this sequence.

```{r}
# Add new cell labels to meta.data
so_vdj <- filter_vdj(
  sobj_in = so_vdj,                                   # Seurat object
  filt    = "CQQSNSWPYTF" %in% cdr3[chain == "IGK"],  # Condition to use for filtering
  new_col = "IGK_seq",                                # Name of new column
  true    = "CQQSNSWPYTF",                            # Value when condition is TRUE
  false   = "other"                                   # Value when condition is FALSE
)

vdj_cols <- c(vdj_cols, "uniq_chains")

so_vdj@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id), n_chains > 2) %>%
  select(all_of(vdj_cols))
```

```{r "seq_umap", fig.width = 12, fig.height = 5, echo = FALSE}
# Plot colors
seq_cols <- so_vdj@meta.data %>%
  pull(IGK_seq) %>%
  unique() %>%
  na.omit()

seq_cols <- set_names(
  x  = get_cols()[c(4, 7)],
  nm = seq_cols
)

seq_cols["NA"] <- "#f0f0f0"

# Sequence UMAP
seq_umap <- so_vdj %>%
  plot_features(
    feature    = "IGK_seq",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = seq_cols
  ) +
  ggtitle("IGK sequence") +
  guides(color = create_guide(nrow = 2)) +
  umap_theme +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Sequence bar graphs
seq_bars <- so_vdj %>%
  plot_cell_count(
    group_id  = "mouse",
    fill_id   = "IGK_seq",
    plot_cols = seq_cols,
    bar_line  = 0.2
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  base_theme +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank()
  )

seq_bars <- plot_grid(
  seq_bars, NULL,
  rel_widths = c(0.4, 1)
)

# Final figure
plot_grid(
  seq_umap, seq_bars,
  rel_widths = c(0.65, 1),
  nrow  = 1,
  align = "h",
  axis  = "tb"
)
```

<br>

### Repertoire stats

The functions `calc_diversity` and `calc_jaccard` will calculate repertoire diversity and repertoire overlap on a per-cluster basis. These functions can be given any meta.data column containing cell labels to use for calculations.

Calculate repertoire diversity with `calc_diversity`. The inverse Simpson index is used to measure diversity for each cluster.

```{r}
so_vdj <- calc_diversity(
  sobj_in       = so_vdj,          # Seurat object
  clonotype_col = "clonotype_id",  # meta.data column containing clonotype ids
  cluster_col   = "type_mouse",    # meta.data column containing cell labels
  prefix        = ""               # Prefix to add to new meta.data columns
)
```

```{r "div_umap", fig.width = 12, fig.height = 5, echo = FALSE}
div_gg <- so_vdj %>%
  plot_features(
    feature    = "diversity",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = c("grey90", get_cols()[1]),
    na_value   = "grey60"
  ) +
  ggtitle("Repertoire Diversity") +
  guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
  umap_theme +
  theme(legend.title = element_blank())

hel_gg <- so_vdj %>%
  plot_features(
    feature    = "adt_HEL",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = c("grey90", get_cols()[6])
  ) +
  ggtitle("HEL") +
  guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
  umap_theme +
  theme(legend.title = element_blank())

plot_grid(
  div_gg, hel_gg,
  align  = "vh",
  "axis" = "trbl"
)
```

<br>

Calculate repertoire overlap with `calc_jaccard` for the cell groups present in the `cluster_col`. Using the `return_seurat` argument, `calc_jaccard` can also output a matrix for plotting.

```{r}
so_vdj <- calc_jaccard(
  sobj_in       = so_vdj,             # Seurat object
  clonotype_col = "clonotype_id",     # meta.data column containing clonotype ids
  cluster_col   = "seurat_clusters",  # meta.data column containing cell labels
  prefix        = "x",                # Prefix to add to new meta.data columns 
  return_seurat = TRUE                # Return Seurat object with results added to meta.data
)
```

```{r "jaccard_umap", fig.width = 12.5, fig.height = 5, echo = FALSE}
# Jaccard UMAP
j_gg <- so_vdj %>%
  plot_features(
    feature    = "x8_jaccard",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = c("grey90", get_cols()[2]),
    na_value   = "grey60"
  ) +
  ggtitle("Repertoire Overlap") +
  guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
  umap_theme +
  theme(legend.text = element_text(size = 8))

# Matrix for heatmap
j_mat <- calc_jaccard(
  sobj_in       = so_vdj,
  clonotype_col = "clonotype_id",
  cluster_col   = "seurat_clusters",
  prefix        = "x",
  return_seurat = FALSE
)

heat_data <- j_mat %>%
  as_tibble(rownames = "Var1") %>%
  pivot_longer(cols = -Var1, names_to = "Var2", values_to = "jaccard") %>%
  mutate(
    jaccard = ifelse(jaccard == 1, NA, jaccard),
    across(
      all_of(c("Var1", "Var2")),
      ~ str_extract(.x, "(?<=x)[0-9]+")
    )
  ) %>%
  rowwise() %>%  
  mutate(key = str_c(sort(c(Var1, Var2)), collapse = "_")) %>%
  group_by(key) %>%
  mutate(jaccard = ifelse(row_number() == 2, NA, jaccard))

# Jaccard heatmap  
j_heat <- heat_data %>%
  ggplot(aes(Var1, rev(Var2), fill = jaccard)) +
  geom_tile(size = 1, color = "white") +
  scale_fill_gradient(
    low      = "grey90",
    high     = get_cols()[2],
    na.value = "white"
  ) +
  guides(fill = guide_colorbar(barwidth = unit(5, "pt"))) +
  base_theme +
  theme(
    legend.text = element_text(size = 8),
    axis.title  = element_blank(),
    axis.line   = element_blank(),
    axis.ticks  = element_blank()
  )

# Final figure
plot_grid(
  j_gg, j_heat,
  align = "h",
  axis  = "tb"
  )
```

```{r "enclone_test", eval = FALSE, echo = FALSE}
# To run enclone
#enclone \
#    BCR=BCR/outs \
#    REF=ref/refdata-cellranger-vdj-GRCm38-alts-ensembl-3.1.0/fasta/regions.fa \
#    POUT="enclone_out.csv" \
#    PCOLS=group_id,group_ncells,clonotype_id,clonotype_ncells,barcodes

# Import enclone results
en_df <- read_csv("~/Projects/Smith_AVIDseq/2020-07-17/enclone_out.csv") %>%
  mutate(barcodes = str_split(barcodes, ",")) %>%
  unnest(barcodes) %>%
  select(cell_id = barcodes, group_id, group_ncells) %>%
  filter(group_ncells > 1)

# Merge enclone groups with meta.data
en_df <- so_vdj@meta.data %>%
  as_tibble(rownames = "cell_id") %>%
  left_join(en_df, by = "cell_id") %>%
  mutate(
    group_id = as.character(group_id),
    group_id = replace_na(group_id, "NA")
  )

# Group colors
grp_cols <- en_df %>%
  pull(group_id) %>%
  unique()

grp_cols <- set_names(
  x  = c(ito_cols, darken(ito_cols, 0.2))[seq_along(grp_cols)],
  nm = grp_cols
)

grp_cols["NA"] <- "white"

# Overlay enclone groups on UMAP
en_df %>%
  mutate(group_id = fct_relevel(group_id, names(grp_cols))) %>%
  plot_features(
    x          = "vdjUMAP_1",
    y          = "vdjUMAP_2",
    feature    = "group_id",
    pt_outline = 0.3,
    plot_cols  = grp_cols
  ) +
  umap_theme +
  guides(color = guide_legend(override.aes = list(size = 3))
```





