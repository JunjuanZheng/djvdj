---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse  = TRUE,
  comment   = "#>",
  fig.path  = "man/figures/README-",
  # out.width = "100%",
  warning   = FALSE,
  message   = FALSE
)
```

# djvdj <img src="man/figures/djvdj-logo.png" align="right" height="145">

<!-- badges: start -->
[![R build status](https://github.com/rnabioco/djvdj/workflows/R-CMD-check/badge.svg)](https://github.com/rnabioco/djvdj/actions)
<!-- badges: end -->

The goal of djvdj is to provide tools to analyze AVID-seq signals alongside single-cell VDJ sequencing data.

<br>

## Installation

You can install the development version of djvdj from [GitHub](https://github.com/rnabioco/djvdj) with:

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("rnabioco/djvdj")
```

```{r "Setup", include = FALSE}
# Packages
library(tidyverse)
library(Seurat)
library(djvdj)
library(cowplot)
library(colorblindr)
library(here)

# Themes
text_theme <- theme(
  legend.title = element_text(size = 10),
  legend.text  = element_text(size = 10),
  axis.title   = element_text(size = 12),
  axis.text    = element_text(size = 10)
)

base_theme <- theme_cowplot() +
  theme(
    plot.title       = element_text(face = "plain", size = 20),
    strip.background = element_blank(),
    strip.text       = element_text(face = "plain"),
    axis.line        = element_line(color = "grey85"),
    axis.ticks       = element_line(color = "grey85")
  ) +
  text_theme

umap_theme <- base_theme +
  theme(
    axis.title = element_blank(),
    axis.line  = element_blank(),
    axis.ticks = element_blank(),
    axis.text  = element_blank()
  )

# Legend guides
create_guide <- function(size = 3.5, shape = 16, nrow = NULL,
                         ncol = NULL, ...) {
  guide_legend(
    nrow = nrow,
    ncol = ncol,
    override.aes = list(
      size   = size,
      shape  = shape,
      ...
    )
  )
}

col_guide <- create_guide(shape = 16, stroke = NULL, color = NULL)

# Okabe Ito color palettes
ito_cols <- c(
  palette_OkabeIto[1:4], "#d7301f", 
  palette_OkabeIto[5:6], "#6A51A3", 
  palette_OkabeIto[7:8], "#875C04"
)

# Set default color palette
create_gradient <- function(cols_in, n = NULL) {
  if (is.null(n)) {
    n <- length(cols_in)
  }
  
  colorRampPalette(cols_in)(n)
}

create_col_fun <- function(cols_in) {
  function(n = NULL) {
    create_gradient(cols_in, n)
  }
}

get_cols <- create_col_fun(ito_cols)
```

<br>

## TCR analysis

Write a description here...

```{r "rna_umap", fig.width = 12.5, fig.height = 5, echo = FALSE}
load(here("data/so_tcr.rda"))

key_umap <- so_tcr %>%
  plot_features(
    feature     = "orig.ident",
    pt_size     = 0.02,
    plot_colors = get_cols()
  ) +
  ggtitle("Cell type") +
  guides(color = create_guide()) +
  umap_theme +
  theme(legend.title = element_blank())

clust_umap <- so_tcr %>%
  plot_features(
    feature     = "seurat_clusters",
    pt_size     = 0.02,
    plot_colors = get_cols(22)
  ) +
  ggtitle("Cluster") +
  guides(color = create_guide()) +
  umap_theme +
  theme(legend.title = element_blank())

plot_grid(
  key_umap, clust_umap,
  rel_widths = c(1, 0.9),
  align      = "h",
  axis       = "tb"
)
```

<br>

### Import VDJ data

`import_vdj` takes the output files from `cellranger vdj` and adds clonotype information to the meta.data for an existing Seurat object. For cells with multiple chains, the information for each chain is stored as a single row, separated by a ";" (or a character specified by `sep`). For cells that do not have any VDJ sequencing data, NAs will be added to the meta.data.

If the Seurat object contains data for multiple runs, a vector containing paths to the VDJ data for each sample can be given. If multiple paths are provided, cell prefixes should be included as names for the vector. 

```{r "import_vdj"}
# Create vector of paths for cellranger output
samples <- levels(so_tcr$orig.ident)
paths   <- file.path("data", str_c(samples, "_TCR"), "outs")

names(paths) <- str_c(samples, "_GE")

# Import VDJ data
so_tcr <- import_vdj(
  sobj_in         = so_tcr,  # Seurat object
  vdj_dir         = paths,   # Directories containing cellranger output files
  prefix          = "",      # Prefix to add to new meta.data columns
  filter_contigs = TRUE      # Only include chains with at least one productive contig
)

# Take a look at the added meta.data
vdj_cols <- c(
  "clonotype_id", "cdr3",
  "chains", "v_gene", 
  "j_gene", "reads",
  "umis"
)

so_tcr@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

<br>

### Filtering

`filter_vdj` allows you to filter a Seurat object using the added clonotype information or any other columns present in the meta.data. When filtering, columns with VDJ data will be expanded based on the delimiter ";" (or a character passed to `sep`). The columns that are expanded for filtering can be specified with the `vdj_cols` argument. By default filtering is only performed on cells that include VDJ data.

Filter to only include cells with paired alpha and beta chains.

```{r}
so_filt <- filter_vdj(
  sobj_in  = so_tcr,                            # Seurat object
  filt     = all(c("TRA", "TRB") %in% chains),  # Expression for filtering
  vdj_cols = "chains"
)

# Take a look at the meta.data
so_filt@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

<br>

Instead of filtering, `filter_vdj` can also add a new column to the object meta.data using the `new_col` argument. The values present in `new_col` will be based on the values (or expression) passed to the `true` and `false` arguments.

In this example a new column is added indicating whether the cell has a paired alpha and beta chain. This is useful for generating new cell labels for plotting.

```{r}
so_tcr <- filter_vdj(
  sobj_in = so_tcr,                            # Seurat object
  filt    = all(c("TRA", "TRB") %in% chains),  # Condition to use for filtering
  new_col = "Paired",                          # Name of new column
  true    = "paired",                          # Value when condition is TRUE
  false   = "unpaired"                         # Value when condition is FALSE
)

# Take a look at the meta.data
vdj_cols <- c(vdj_cols, "Paired")

so_tcr@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

```{r "pair_umap", fig.width = 12, fig.height = 5, echo = FALSE}
# Plot colors
pairs_cols <- so_tcr@meta.data %>%
  pull(Paired) %>%
  unique() %>%
  na.omit()

pairs_cols <- set_names(
  x  = get_cols()[seq_along(pairs_cols)],
  nm = pairs_cols
)

pairs_cols["NA"] <- "#f0f0f0"

# Paired UMAP
pairs_umap <- so_tcr %>%
  plot_features(
    x           = "UMAP_1",
    y           = "UMAP_2",
    feature     = "Paired",
    pt_size     = 0.02,
    plot_colors = pairs_cols
  ) +
  ggtitle("Paired chains") +
  guides(color = create_guide(nrow = 2)) +
  umap_theme +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Paired bar graphs
pairs_bars <- so_tcr %>%
  plot_cell_count(
    x           = "orig.ident",
    fill_col    = "Paired",
    plot_colors = pairs_cols
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  base_theme +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1)
  )

pairs_bars <- plot_grid(
  pairs_bars, NULL,
  rel_widths = c(0.4, 1)
)

# Final figure
plot_grid(
  pairs_umap, pairs_bars,
  rel_widths = c(0.65, 1),
  nrow  = 1,
  align = "h",
  axis  = "tb"
)
```

<br>

More complicated statements referring to meta.data columns can be used for the `filt`, `true`, and `false` arguments. For more detailed analysis of the chains detected for each cell, a new cell label can be created for only the unique chains detected in each cell.

```{r}
so_tcr <- filter_vdj(
  sobj_in = so_tcr,                                # Seurat object
  new_col = "uniq_chains",                         # Name of new column
  true    = str_c(unique(chains), collapse = "_")  # Value when condition is TRUE
)

# Take a look at the meta.data
vdj_cols <- c(vdj_cols, "uniq_chains")

so_tcr@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id), n_chains > 2) %>%
  select(all_of(vdj_cols))
```

```{r "chains_umap", fig.width = 12, fig.height = 5, echo = FALSE}
# Plot colors
chains_cols <- so_tcr@meta.data %>%
  pull(uniq_chains) %>%
  unique() %>%
  na.omit()

chains_cols <- set_names(
  x  = get_cols()[seq_along(chains_cols)],
  nm = chains_cols
)

chains_cols["NA"] <- "#f0f0f0"

# Chains UMAP
chains_umap <- so_tcr %>%
  plot_features(
    feature     = "uniq_chains",
    pt_size     = 0.02,
    plot_colors = chains_cols
  ) +
  ggtitle("Unique chains") +
  guides(color = create_guide(nrow = 2)) +
  umap_theme +
  theme(
    legend.position = "top",
    legend.title = element_blank()
  )

# Chains bar graphs
chains_bars <- so_tcr %>%
  plot_cell_count(
    x           = "orig.ident",
    fill_col    = "uniq_chains",
    plot_colors = chains_cols
  ) +
  scale_y_continuous(breaks = c(0, 0.5, 1)) +
  base_theme +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1)
  )

chains_bars <- plot_grid(
  chains_bars, NULL,
  rel_widths = c(0.4, 1)
)

# Final figure
plot_grid(
  chains_umap, chains_bars,
  rel_widths = c(0.65, 1),
  nrow       = 1,
  align      = "h",
  axis       = "tb"
)
```

<br>

### Clonotype Abundance

To identify the top clonotypes in each sample or cluster, clonotype abundance can be calculated using the `calc_abundance` function.

```{r, eval = F}
x <- calc_abundance(
  sobj_in       = so_tcr,        # Seurat object
  clonotype_col = "cdr3",        # meta.data column containing clonotype IDs
  cluster_col   = "orig.ident",  # meta.data column containing cell labels
  prefix        = ""             # Prefix to add to new meta.data columns
)
```

<br>

### Repertoire Diversity

The function `calc_diversity` will calculate repertoire diversity on a per-cluster basis. Using the `cluster_col` argument, any meta.data column containing cell labels can be used for calculations. `calc_diversity` uses the R package `abdiv` for performing diversity calculations and any `abdiv` diversity function can be specified using the `method` argument.

Possible methods for calculating diversity include:

```{r, echo = F}
abdiv::alpha_diversities
```
<br>

In this example we are calculating the Shannon index of diversity for each sample in the orig.ident meta.data column.

```{r}
so_tcr <- calc_diversity(
  sobj_in       = so_tcr,         # Seurat object
  clonotype_col = "cdr3",         # meta.data column containing clonotype ids
  cluster_col   = "orig.ident",   # meta.data column containing cell labels
  method        = abdiv::shannon  # abdiv method to use
)
```

<br>

For each 'calculation' function provided by `djvdj`, there is a matching `plot` function that will generate a summary plot. For `plot_diversity` this is a bar graph.

```{r "div_plots", fig.width = 3, fig.height = 4}
plot_diversity(
  sobj_in       = so_tcr,          # Seurat object
  clonotype_col = "cdr3",          # meta.data column containing clonotype ids
  cluster_col   = "orig.ident",    # meta.data column containing cell labels
  method        = abdiv::shannon,  # abdiv method to use
  plot_colors   = ito_cols 
) +
  theme_cowplot() +
  theme(
    legend.position = "none",
    axis.title.x    = element_blank(),
    axis.text.x     = element_text(angle = 45, hjust = 1)
  )
```

<br>

### Repertoire Overlap

To compare repertoires for different samples or clusters, `calc_similarity` can calculate a variety of different similarity metrics. The `cluster_col` should be used to specify the meta.data column containing cell labels for comparison. Like `calc_diversity`, an `abdiv` function can be specified with the `method` argument.

Possible methods for calculating repertoire similarity include:

```{r, echo = F}
abdiv::beta_diversities
```

<br>

By default `calc_similarity` will add a new meta.data column for each comparison. In this example we are calculating the jaccard dissimilarity index for all combinations of cell labels present in the `orig.ident` column.

```{r}
so_tcr <- calc_similarity(
  sobj_in       = so_tcr,          # Seurat object
  clonotype_col = "cdr3",          # meta.data column containing clonotype ids
  cluster_col   = "orig.ident",    # meta.data column containing cell labels
  method        = abdiv::jaccard,  # abdiv method to use
  prefix        = "jcrd_",         # Prefix to add to new meta.data columns 
  return_seurat = TRUE             # Return Seurat object with results added to meta.data
)

# Take a look at the meta.data
so_tcr@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id), n_chains > 2) %>%
  select(all_of(vdj_cols), starts_with("jcrd_"))
```

<br>

Alternatively, `calc_similarity` can output a matrix

```{r}
calc_similarity(
  sobj_in       = so_tcr,          # Seurat object
  clonotype_col = "cdr3",          # meta.data column containing clonotype ids
  cluster_col   = "orig.ident",    # meta.data column containing cell labels
  method        = abdiv::jaccard,  # abdiv method to use
  return_seurat = FALSE            # Return Seurat object with results added to meta.data
)
```

<br>

A heatmap summarizing the results can be generated using the `plot_similarity` function. Here we are creating two heatmaps, one to compare the different samples and one to compare cell clusters.

```{r "sim_plots", fig.width = 8, fig.height = 2.7}
# Sample heatmap
ident_heat <- plot_similarity(
  sobj_in       = so_tcr,
  clonotype_col = "cdr3",
  cluster_col   = "orig.ident",
  method        = abdiv::jaccard,
  plot_colors   = c("grey90", "#56B4E9")
) +
  theme(legend.title = element_blank())

# Cluster heatmap
clust_heat <- plot_similarity(
  sobj_in       = so_tcr,
  clonotype_col = "cdr3",
  cluster_col   = "seurat_clusters",
  method        = abdiv::jaccard,
  plot_colors   = c("grey90", "#56B4E9"),
  
  size          = 1,       # Additional options to pass to ggplot
  color         = "white"  # Additional options to pass to ggplot
) +
  theme(legend.title = element_blank())

# Combine heatmaps
plot_grid(ident_heat, clust_heat)
```

<br>

### VDJ Gene Usage

The V(D)J data imported from Cell Ranger also includes the specific genes detected for each cell. The function `calc_usage` can be used to calculate the fraction of cells that express different V(D)J genes. This function will produce a table summarizing the results. To only include results for a certain chain, the `chain` and `chain_col` arguments can be used to specify the meta.data column containing the chains detected for each cell. By default the results for all chains will be included.

In this example we are summarizing the usage of different V genes for the TRB chain 

```{r}
calc_usage(
  sobj_in     = so_tcr,        # Seurat object
  gene_cols   = "v_gene",      # meta.data column containing genes
  cluster_col = "orig.ident",  # meta.data column containing cell labels
  chain       = "TRB",         # Chain to use for filtering genes
  chain_col   = "chains"       # meta.data column containing chains identified for each cell
)
```

<br>

The companion function `plot_usage` can be used to create a heatmap summarizing these results. Using the `yaxis` argument, the percent or absolute count (frequency) can be used for plotting. The genes plotting can also be selected using the `plot_genes` argument, or the total number of genes to plot can be passed to `n_genes`.

In this example we are only plotting the top 10 genes that have the highest average usage.

```{r "usage_plots_1", fig.width = 4.5, fig.height = 5}
plot_usage(
  sobj_in     = so_tcr,                    # Seurat object
  gene_cols   = "v_gene",                  # meta.data column(s) containing genes
  cluster_col = "orig.ident",              # meta.data column containing cell labels
  chain       = "TRB",                     # Chain to use for filtering genes
  chain_col   = "chains",                  # meta.data column containing chains
  
  plot_colors = c("grey90", ito_cols[5]),  # Colors to use for heatmap
  plot_genes  = NULL,                      # A list of genes to plot
  n_genes     = 10,                        # The number of top genes to plot
  yaxis       = "percent"                  # Units to plot
)
```

<br>

By passing multiple columns to `gene_cols`, the frequency that different genes are used together can also be summarized.

```{r}
calc_usage(
  sobj_in     = so_tcr,                 # Seurat object
  gene_cols   = c("v_gene", "j_gene"),  # meta.data column(s) containing genes
  cluster_col = "orig.ident",           # meta.data column containing cell labels
  chain       = "TRB",                  # Chain to use for filtering genes
  chain_col   = "chains"                # meta.data column containing chains
)
```

<br>

When multiple gene columns are passed to `plot_usage`, a list of plots will be returned, one for each cell label in the `cluster_col` column.

```{r "usage_plots_2", fig.width = 12, fig.height = 8}
gg <- plot_usage(
  sobj_in     = so_tcr,                   # Seurat object
  gene_cols   = c("v_gene", "j_gene"),    # meta.data column(s) containing genes
  cluster_col = "orig.ident",             # meta.data column containing cell labels
  chain       = "TRB",                    # Chain to use for filtering genes
  chain_col   = "chains",                 # meta.data column containing chains identified
  plot_colors = c("grey90", ito_cols[8])  # Colors to use for heatmap
) %>%
  imap(~ .x + ggtitle(.y))

# Combine heatmaps
plot_grid(plotlist = gg)
```





```{r "enclone_test", eval = FALSE, echo = FALSE}
# To run enclone
#enclone \
#    BCR=BCR/outs \
#    REF=ref/refdata-cellranger-vdj-GRCm38-alts-ensembl-3.1.0/fasta/regions.fa \
#    POUT="enclone_out.csv" \
#    PCOLS=group_id,group_ncells,clonotype_id,clonotype_ncells,barcodes

# Import enclone results
en_df <- read_csv("~/Projects/Smith_AVIDseq/2020-07-17/enclone_out.csv") %>%
  mutate(barcodes = str_split(barcodes, ",")) %>%
  unnest(barcodes) %>%
  select(cell_id = barcodes, group_id, group_ncells) %>%
  filter(group_ncells > 1)

# Merge enclone groups with meta.data
en_df <- so_tcr@meta.data %>%
  as_tibble(rownames = "cell_id") %>%
  left_join(en_df, by = "cell_id") %>%
  mutate(
    group_id = as.character(group_id),
    group_id = replace_na(group_id, "NA")
  )

# Group colors
grp_cols <- en_df %>%
  pull(group_id) %>%
  unique()

grp_cols <- set_names(
  x  = c(ito_cols, darken(ito_cols, 0.2))[seq_along(grp_cols)],
  nm = grp_cols
)

grp_cols["NA"] <- "white"

# Overlay enclone groups on UMAP
en_df %>%
  mutate(group_id = fct_relevel(group_id, names(grp_cols))) %>%
  plot_features(
    x          = "vdjUMAP_1",
    y          = "vdjUMAP_2",
    feature    = "group_id",
    pt_outline = 0.3,
    plot_colors  = grp_cols
  ) +
  umap_theme +
  guides(color = guide_legend(override.aes = list(size = 3))
```





