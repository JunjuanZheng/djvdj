---
output: github_document
params:
  vdj_dir: "~/Projects/Smith_AVIDseq/2020-07-17/BCR/outs"
  clust_res: 0.2
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse  = TRUE,
  comment   = "#>",
  fig.path  = "man/figures/README-",
  out.width = "100%",
  warning   = FALSE,
  message   = FALSE
)
```

# djvdj <img src="man/figures/djvdj-logo.png" align="right" height="139">

<!-- badges: start -->
[![R build status](https://github.com/rnabioco/djvdj/workflows/R-CMD-check/badge.svg)](https://github.com/rnabioco/djvdj/actions)
[![codecov](https://codecov.io/gh/rnabioco/djvdj/branch/master/graph/badge.svg)](https://codecov.io/gh/vjvdj/clustifyr)
<!-- badges: end -->

The goal of djvdj is to provide tools to analyze AVID-seq signals alongside single-cell VDJ sequencing data.

<br>

### Installation

You can install the development version of djvdj from [GitHub](https://github.com/rnabioco/djvdj) with:

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("rnabioco/djvdj")
```

```{r "functions", echo = FALSE}
# Create color palette
create_gradient <- function(cols_in, n = NULL) {
  
  if (is.null(n)) {
    n <- length(cols_in)
  }
  
  colorRampPalette(cols_in)(n)
}

create_col_fun <- function(cols_in) {
  
  function(n = NULL) {
    create_gradient(cols_in, n)
  }
}

# Overlay feature data on UMAP or tSNE
# Cannot change number of columns when using FeaturePlot with split.by
plot_features <- function(sobj_in, x = "UMAP_1", y = "UMAP_2", feature, data_slot = "data", 
                          split_id = NULL, pt_size = 0.25, pt_outline = NULL, plot_cols = NULL,
                          feat_levels = NULL, split_levels = NULL, min_pct = NULL, max_pct = NULL, 
                          calc_cor = F, lm_line = F, lab_size = 3.7, lab_pos = c(0.8, 0.9),
                          na_value = "#fafafa", ...) {
  
  # Format imput data
  counts <- sobj_in
  
  if ("Seurat" %in% class(sobj_in)) {
    vars <- c(x, y, feature)
    
    if (!is.null(split_id)) {
      vars <- c(vars, split_id)
    }

    counts <- sobj_in %>%
      FetchData(vars = unique(vars), slot = data_slot) %>%
      as_tibble(rownames = "cell_ids")
  }
  
  # Rename features
  if (!is.null(names(feature))) {
    counts <- counts %>%
      rename(!!!syms(feature))
    
    feature <- names(feature)
  }
  
  if (!is.null(names(x))) {
    counts <- counts %>%
      rename(!!!syms(x))
    
    x <- names(x)
  }
  
  if (!is.null(names(y))) {
    counts <- counts %>%
      rename(!!!syms(y))
    
    y <- names(y)
  }
  
  # Set min and max values for feature
  if (!is.null(min_pct) || !is.null(max_pct)) {
    counts <- counts %>%
      mutate(
        pct_rank = percent_rank(!!sym(feature)),
        max_val  = ifelse(pct_rank > max_pct, !!sym(feature), NA),
        max_val  = min(max_val, na.rm = T),
        min_val  = ifelse(pct_rank < min_pct, !!sym(feature), NA),
        min_val  = max(min_val, na.rm = T),
        !!sym(feature) := if_else(!!sym(feature) > max_val, max_val, !!sym(feature)),
        !!sym(feature) := if_else(!!sym(feature) < min_val, min_val, !!sym(feature))
      )
  }

  # Set feature order
  if (!is.null(feat_levels)) {
    counts <- counts %>%
      mutate(!!sym(feature) := fct_relevel(!!sym(feature), feat_levels))
  }
  
  # Set facet order
  if (!is.null(split_id) && length(split_id) == 1) {
    counts <- counts %>%
      mutate(split_id = !!sym(split_id))
    
    if (!is.null(split_levels)) {
      counts <- counts %>%
        mutate(split_id = fct_relevel(split_id, split_levels))
    }
  }
  
  # Calculate correlation
  if (calc_cor) {
    if (!is.null(split_id)) {
      counts <- counts %>%
        group_by(split_id)
    }
    
    counts <- counts %>%
      mutate(
        r       = tidy(cor.test(!!sym(x), !!sym(y)))$estimate,
        r       = round(r, digits = 2),
        pval    = tidy(cor.test(!!sym(x), !!sym(y)))$p.value,
        cor_lab = str_c("r = ", r, ", p = ", format(pval, digits = 2))
        
        # cor_lab = cor(!!sym(x), !!sym(y)),
        # cor_lab = round(cor_lab, digits = 2),
        # cor_lab = str_c("r = ", cor_lab),
      )
    
    if (lab_pos != "strip") {
      counts <- counts %>%
        mutate(
          min_x = min(!!sym(x)),
          max_x = max(!!sym(x)),
          min_y = min(!!sym(y)),
          max_y = max(!!sym(y)),
          lab_x = (max_x - min_x) * lab_pos[1] + min_x,
          lab_y = (max_y - min_y) * lab_pos[2] + min_y
        )
    }
  }
  
  # Create scatter plot
  # To add outline for each cluster create separate layers
  res <- counts %>%
    arrange(!!sym(feature))
  
  if (!is.null(pt_outline)) {
    
    if (!is.numeric(counts[[feature]])) {
      res <- res %>%
        ggplot(aes(!!sym(x), !!sym(y), color = !!sym(feature), fill = !!sym(feature)))
      
      feats <- counts[[feature]] %>%
        unique()
      
      if (!is.null(feat_levels)) {
        feats <- feat_levels[feat_levels %in% feats]
      }
      
      for (feat in feats) {
        f_counts <- counts %>%
          filter(!!sym(feature) == feat)
        
        res <- res +
          geom_point(data = f_counts, aes(fill = !!sym(feature)), size = pt_outline, color = "black", show.legend = F) +
          geom_point(data = f_counts, size = pt_size)
      }
      
    } else {
      res <- res %>%
        ggplot(aes(!!sym(x), !!sym(y), color = !!sym(feature))) +
        geom_point(aes(fill = !!sym(feature)), size = pt_outline, color = "black", show.legend = F) +
        geom_point(size = pt_size)
    }
    
  } else {
    res <- res %>%
      ggplot(aes(!!sym(x), !!sym(y), color = !!sym(feature))) +
      geom_point(size = pt_size)
  }

  # Add regression line
  if (lm_line) {
    res <- res +
      geom_smooth(
        method   = "lm",
        se       = F,
        color    = "black",
        size     = 0.5,
        linetype = 2
      )
  }
  
  # Add correlation coefficient label
  if (calc_cor && lab_pos != "strip") {
    res <- res +
      geom_text(
        mapping       = aes(lab_x, lab_y, label = cor_lab),
        color         = "black",
        size          = lab_size,
        check_overlap = T, 
        show.legend   = F
      )
  }
  
  # Set feature colors
  if (!is.null(plot_cols)) {
    if (is.numeric(counts[[feature]])) {
      res <- res +
        scale_color_gradientn(colors = plot_cols, na.value = na_value)
        # scale_color_gradient(low = plot_cols[1], high = plot_cols[2])

    } else {
      res <- res +
        scale_color_manual(values = plot_cols, na.value = na_value) +
        scale_fill_manual(values = plot_cols, na.value = na_value)
    }
  }
  
  # Split plot into facets
  cor_labeller <- function(labels) {
    labels %>%
      map(~ {
        cor_labs <- counts %>%
          ungroup() %>%
          select(!!sym(feature), cor_lab) %>%
          unique()
        
        cor_labs <- set_names(cor_labs$cor_lab, cor_labs[[feature]])
        
        str_c(.x, "\n", cor_labs[.x])
      })
  }
  
  if (!is.null(split_id)) {
    if (length(split_id) == 1) {
      
      if (calc_cor && lab_pos == "strip") {
        my_labs <- cor_labeller
        
      } else {
        my_labs <- "label_value"
      }
      
      res <- res +
        facet_wrap(~ split_id, labeller = my_labs, ...)
      
    } else if (length(split_id) == 2) {
      eq <- str_c(split_id[1], " ~ ", split_id[2])
      
      res <- res +
        facet_grid(as.formula(eq), ...)
    }
  }
  
  res
}
```

```{r "Setup", include = FALSE}
# Packages
library(tidyverse)
library(cowplot)
library(colorblindr)
library(Seurat)
library(here)
library(djvdj)

# Themes
base_theme <- theme_cowplot() +
  theme(
    plot.title       = element_text(face = "plain", size = 16),
    strip.background = element_blank(),
    strip.text       = element_text(face = "plain"),
    legend.title     = element_text(size = 10),
    legend.text      = element_text(size = 10),
    axis.title       = element_text(size = 10),
    axis.text        = element_text(size = 10)
  )

umap_theme <- base_theme +
  theme(
    panel.border = element_rect(color = "grey90", size = 1),
    axis.title   = element_blank(),
    axis.line    = element_blank(),
    axis.ticks   = element_blank(),
    axis.text    = element_blank()
  )

# Legend guides
col_guide <- guide_legend(override.aes = list(size = 3.5, shape = 16))

outline_guide <- guide_legend(override.aes = list(
  size   = 3.5,
  shape  = 21,
  color  = "black",
  stroke = 0.25
))

# Okabe Ito color palettes
ito_cols <- c(
  palette_OkabeIto[1:4], "#d7301f", 
  palette_OkabeIto[5:6], "#6A51A3", 
  palette_OkabeIto[7:8], "#875C04"
)

# Set default palette
get_cols <- create_col_fun(ito_cols)
```

<br>

## Vignette

Splenocytes from MD4 transgenic mice which have monoclonal B cells that all bind hen egg lysozyme (HEL) antigen were mixed with splenocytes from C57BL/6 mice at a 1:1 ratio. The cells were stained with the HEL AVID-tag and sequencing libraries were prepared to capture gene expression, B/T cell receptor sequences, and AVID-tag signals using the 10x Genomics 5â€™ immune profiling kit.

```{r "rna_umap", fig.width = 12.5, fig.height = 5, echo = FALSE}
key_gg <- so %>%
  plot_features(
    feature    = "type_mouse",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = get_cols()
  ) +
  guides(color = outline_guide) +
  umap_theme +
  theme(
    panel.border = element_blank(),
    legend.title = element_blank()
  )

plot_grid(key_gg, NA)
```

<br>

### Import VDJ data

`import_vdj` takes the output files from `cellranger vdj` and adds clonotype information to the meta.data for an existing Seurat object. For cells that do not have any VDJ sequencing data, NAs will be included in the meta.data.

```{r "import_vdj"}
so_vdj <- import_vdj(
  sobj_in        = so,              # Seurat object                         
  vdj_dir        = params$vdj_dir,  # Directory containing cellranger output files
  prefix         = "",              # Prefix to add to new meta.data columns
  cell_prefix    = "",              # Prefix to add to cell barcodes
  filter_contigs = TRUE             # Only include chains with at least one productive contig
)

vdj_cols <- c(
  "chain",      "cdr3",
  "clone_freq", "clone_prop",
   "n_chains"
)

so_vdj@meta.data %>%
  as_tibble() %>%
  select(orig.ident, nCount_RNA, nFeature_RNA, all_of(vdj_cols))
```

<br>

### Filtering

`filter_vdj` allows you to filter a Seurat object using the added clonotype information or any other columns present in the meta.data. The terms `.chains` and `.seqs` can be used to filter based on the chains detected for the cell or the sequence of the chain. Filtering is only performed on cells that include VDJ data, all other cells will remain in the object.

Filter to only include cells with both IGH and IGK chains

```{r}
so_filt <- filter_vdj(
  sobj_in = so_vdj,                           # Seurat object
  filt    = all(c("IGH", "IGK") %in% chain),  # Expression to use for filtering
)

so_filt@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

<br>

Filter for cells with an IGL chain and at least two cells or >1% that share the clonotype

```{r}
so_filt <- so_vdj %>%
  filter_vdj(chain == "IGL" && clone_freq > 1 || clone_prop > 0.01)

so_filt@meta.data %>%
  as_tibble() %>%
  filter(!is.na(clonotype_id)) %>%
  select(all_of(vdj_cols))
```

<br>

Other examples

```{r, eval = FALSE}
# Cells with CDR3 amino acid sequence of 'CQQSNSWPYTF'
so_filt <- so_vdj %>%
  filter_vdj(cdr3 == 'CQQSNSWPYTF')

# Cells with IGH, IGK, and IGL chains
so_filt <- so_vdj %>%
  filter_vdj(all(c("IGH", "IGK", "IGL") %in% chain))

# Cells with two IGK chains and no other chains and >1000 RNA counts
so_filt <- so_vdj %>%
  filter_vdj(all(chain == "IGK") && n_chains == 2 && nCount_RNA > 1000)

# Cells with at least two unique chains and no IGH chain
so_filt <- so_vdj %>%
  filter_vdj(all(chain != "IGH") && length(unique(chain)) > 1)
```

<br>

### Clustering

Cells can be clustered based on the Levenshtein distance between CDR3 sequences using `cluster_vdj`. The `use_chains` argument can be used to select the chains that should be used when performing distance calculations.

```{r}
so_vdj <- cluster_vdj(
  sobj_in    = so_vdj,            # Seurat object
  cdr3_col   = "cdr3",            # meta.data column containing CDR3 sequences
  resolution = params$clust_res,  # Clustering resolution
  use_chains = NULL,              # Chains to use for distance calculations
  prefix     = "vdj_"             # Prefix to add to new graph
)

so_vdj@meta.data %>%
  as_tibble() %>%
  select(all_of(vdj_cols), seurat_clusters)
```

<br>

The Seurat `RunUMAP` function will not run with the hybrid VDJ object, but the wrapper function `run_umap_vdj` can be used.

```{r}
so_vdj <- run_umap_vdj(
  sobj_in   = so_vdj,      # Seurat object
  umap_key  = "vdjUMAP_",  # Prefix for UMAP columns
  vdj_graph = "vdj_snn"    # Name of VDJ graph to use for UMAP
)
```

```{r "vdj_umap", fig.width = 11, fig.height = 5, echo = FALSE}
rna_gg <- so_vdj %>%
  plot_features(
    feature    = "seurat_clusters",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = get_cols()
  ) +
  ggtitle("RNA") +
  guides(color = outline_guide) +
  umap_theme +
  theme(legend.title = element_blank())

gg_legd <- get_legend(rna_gg)

rna_gg <- rna_gg +
  theme(legend.position = "none")

vdj_gg <- so_vdj %>%
  plot_features(
    x          = "vdjUMAP_1",
    y          = "vdjUMAP_2",
    feature    = "seurat_clusters",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = get_cols()
  ) +
  ggtitle("VDJ") +
  umap_theme +
  theme(legend.position = "none")

plot_grid(
  rna_gg, vdj_gg, gg_legd,
  rel_widths = c(1, 1, 0.2),
  nrow       = 1
)
```

<br>

### Repertoire stats

The functions `calc_diversity` and `calc_jaccard` will calculate repertoire diversity and repertoire overlap on a per-cluster basis. These functions can be given any meta.data column containing cell labels to use for calculations.

Calculate repertoire diversity with `calc_diversity`. The inverse Simpson index is used to measure diversity for each cluster.

```{r}
so_vdj <- calc_diversity(
  sobj_in       = so_vdj,          # Seurat object
  clonotype_col = "clonotype_id",  # meta.data column containing clonotype ids
  cluster_col   = "type_mouse",    # meta.data column containing cell labels
  prefix        = ""               # Prefix to add to new meta.data columns
)
```

```{r "calc_diversity", fig.width = 12, fig.height = 5, echo = FALSE}
div_gg <- so_vdj %>%
  plot_features(
    x          = "vdjUMAP_1",
    y          = "vdjUMAP_2",
    feature    = "diversity",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = c("grey90", get_cols()[1])
  ) +
  ggtitle("Repertoire Diversity") +
  guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
  umap_theme +
  theme(legend.title = element_blank())

hel_gg <- so_vdj %>%
  plot_features(
    x          = "vdjUMAP_1",
    y          = "vdjUMAP_2",
    feature    = "adt_HEL",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = c("grey90", get_cols()[6])
  ) +
  ggtitle("HEL") +
  guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
  umap_theme +
  theme(legend.title = element_blank())

plot_grid(
  div_gg, hel_gg,
  align  = "vh",
  "axis" = "trbl"
)
```

<br>

Calculate repertoire overlap with `calc_jaccard`. A reference cell label can be given to calculate Jaccard index for the reference vs all other cell groups. If no reference is given overlap is calculated for all combinations of cell labels.

```{r}
so_vdj <- calc_jaccard(
  sobj_in       = so_vdj,             # Seurat object
  clonotype_col = "clonotype_id",     # meta.data column containing clonotype ids
  cluster_col   = "seurat_clusters",  # meta.data column containing cell labels
  ref_cluster   = NULL,               # Cell label to use as a reference for Jaccard index
  prefix        = "x"                 # Prefix to add to new meta.data columns 
)
```

```{r "calc_jaccard", fig.width = 12.5, fig.height = 5, echo = FALSE}
j_gg <- so_vdj %>%
  plot_features(
    x          = "vdjUMAP_1",
    y          = "vdjUMAP_2",
    feature    = "x8_jaccard",
    pt_size    = 0.02,
    pt_outline = 0.2,
    plot_cols  = c("grey90", get_cols()[2])
  ) +
  ggtitle("Repertoire Overlap") +
  guides(color = guide_colorbar(barwidth = unit(5, "pt"))) +
  umap_theme

plot_grid(j_gg, NA)
```

